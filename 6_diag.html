---
layout: base
title: Diag
permalink: /diag/
color: red
theme: light
exclude: true
---

<!--
<div id="node-list"></div>
<script>
  // URL to your CSV file (relative to the root of your Jekyll site)
  const csvUrl = "/assets/links.csv"; // Adjust this path as necessary

  // Function to process the CSV data and generate HTML
  function processCSV(csvData) {
    // Parse CSV data using PapaParse
    Papa.parse(csvData, {
      header: true, // Treat first row as headers
      dynamicTyping: true, // Automatically convert numeric values
      complete: function(results) {
        const rows = results.data;
        
        // Hashes to store nodes
        const nameToId = {};  // Maps name (source/dest) to ID
        const idToName = {};  // Maps ID to name (source/dest)
        
        // Start an incremental counter for IDs
        let idCounter = 1;
        
        // Extract unique source and dest values and store them in the hashes
        rows.forEach(row => {
          // For source
          if (!nameToId[row.source]) {
            const id = `node-${idCounter++}`;
            nameToId[row.source] = id;
            idToName[id] = row.source;
          }

          // For destination
          if (!nameToId[row.dest]) {
            const id = `node-${idCounter++}`;
            nameToId[row.dest] = id;
            idToName[id] = row.dest;
          }
        });

        // Generate HTML nodes with incremental IDs
        const sourceNodes = Array.from(new Set(rows.map(row => row.source))).map(source => createNode(source, nameToId[source]));
        const destNodes = Array.from(new Set(rows.map(row => row.dest))).map(dest => createNode(dest, nameToId[dest]));

        // Combine the nodes and display them
        const allNodes = [...sourceNodes, ...destNodes];
        const nodeListHTML = `<ul>${allNodes.join('')}</ul>`;

        // Insert the HTML into the node-list div
        document.getElementById('node-list').innerHTML = nodeListHTML;

        // For debugging: log the hashes to the console
        console.log("nameToId:", nameToId);
        console.log("idToName:", idToName);
      }
    });
  }

  // Function to create an individual node with an incremental ID
  function createNode(value, id) {
    return `<li><div class="node" id="${id}" data-value="${value}">${value}</div></li>`;
  }

  // Fetch the CSV file and process it
  fetch(csvUrl)
    .then(response => response.text())
    .then(csvData => processCSV(csvData))
    .catch(error => console.error("Error loading CSV:", error));
</script>

-->


<!-- <script>
  // URL of the CSV file to be downloaded
  const csvUrl = '../assets/links.csv';  // Replace with the actual URL of your CSV file
  let graphData = {};

  // When the page loads, fetch and process the CSV data
  window.onload = function() {
      fetch(csvUrl)
          .then(response => response.text()) // Fetch the file as text
          .then(csvContent => {
              const data = parseCSV(csvContent); // Manually parse the CSV content
              graphData = convertCSVToGraphData(data);
              console.log(graphData);  // Log the generated graph data to the console
          })
          .catch(error => {
              console.error('Error loading CSV file:', error);
          });
  };

  // Function to manually parse CSV content by splitting rows by commas
  function parseCSV(csvContent) {
      const rows = csvContent.split('\n');  // Split the CSV into rows by line breaks
      const data = [];
      
      // Loop over the rows and split them by commas
      rows.forEach((row, index) => {
          // Skip the header row or any empty rows
          if (index === 0 || !row.trim()) return;

          const columns = row.split(',');  // Split the row by commas to get columns
          const source = columns[0].trim();
          const dest = columns[1].trim();

          // Store the source and destination as an object
          data.push({ source, dest });
      });
      return data;
  }

  // Function to convert CSV data to D3 graph data format
  function convertCSVToGraphData(data) {
      const nodes = [];
      const links = [];

      // Create a map to store unique nodes and their corresponding ids
      const nodeMap = new Map();
      let nodeId = 1;  // Starting ID for nodes

      // Loop through each row of the CSV and construct the links
      data.forEach(row => {
          const source = row.source;
          const dest = row.dest;

          // Add source node if it's not already in the map
          if (!nodeMap.has(source)) {
              nodeMap.set(source, nodeId++);
              nodes.push({ id: nodeMap.get(source), name: source });
          }

          // Add destination node if it's not already in the map
          if (!nodeMap.has(dest)) {
              nodeMap.set(dest, nodeId++);
              nodes.push({ id: nodeMap.get(dest), name: dest });
          }

          // Create the link between source and destination
          links.push({
              source: nodeMap.get(source),
              target: nodeMap.get(dest)
          });
      });

      return { nodes: nodes, links: links };
  }
</script> -->

<script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    svg {
      width: 100%;
      height: 100vh;
      border: 1px solid #ccc;
    }
    .node circle {
      fill: #1f77b4;
      stroke: white;
      stroke-width: 2px;
    }
    .link {
      stroke: #999;
      stroke-opacity: 0.6;
    }
    text {
      font-size: 12px;
      pointer-events: none;
    }
  </style>

<h1>D3.js Network Graph with Force Simulation</h1>

<svg id="network-graph"></svg>

<script>
  // Example JSON input for the network graph (nodes and links)
  // const graphData = {
  //   nodes: [
  //     { id: 'aa', name: 'Node 1' },
  //     { id: 'bb', name: 'Node 2' },
  //     { id: 'cc', name: 'Node 3' },
  //     { id: 'dd', name: 'Node 4' }
  //   ],
  //   links: [
  //     { source: 'aa', target: 'bb' },
  //     { source: 'aa', target: 'bb' },
  //     { source: 'bb', target: 'dd' },
  //     { source: 'cc', target: 'dd' }
  //   ]
  // };

  const graphData = {
    nodes: [
      {% assign node_ids = "" %}
      
      {% for link in site.data.links %}
        {% unless node_ids contains link.source %}
          { id: '{{ link.source | downcase | replace: " ", "" | replace: "&", "" }}', name: '{{ link.source }}' },
          {% assign node_ids = node_ids | append: link.source %}
        {% endunless %}
        
        {% unless node_ids contains link.target %}
          { id: '{{ link.target | downcase | replace: " ", "" | replace: "&", "" }}', name: '{{ link.target }}' },
          {% assign node_ids = node_ids | append: link.target %}
        {% endunless %}
      {% endfor %}
    ],
    links = [
      {% for link in site.data.links %}
            { source: '{{ link.source | downcase | replace: " ", "" | replace: "&", "" }}', target: '{{ link.target | downcase | replace: " ", "" | replace: "&", "" }}' },
      {% endfor %}
    ]
  };

  // Set up the SVG canvas dimensions
  const width = window.innerWidth;
  const height = window.innerHeight;

  const svg = d3.select("#network-graph")
    .attr("width", width)
    .attr("height", height);

  // Set up the simulation with forces (for layout)
  const simulation = d3.forceSimulation(graphData.nodes)
    .force("link", d3.forceLink(graphData.links).id(d => d.id).distance(150))  // Link force
    .force("charge", d3.forceManyBody().strength(-200)) // Node repulsion force
    .force("center", d3.forceCenter(width / 2, height / 2)) // Centering force
    .on("tick", ticked);  // Called every simulation step to update positions

  // Create links (edges between nodes)
  const link = svg.append("g")
    .selectAll(".link")
    .data(graphData.links)
    .enter().append("line")
    .attr("class", "link")
    .attr("stroke-width", 2);

  // Create nodes (circles representing the nodes)
  const node = svg.append("g")
    .selectAll(".node")
    .data(graphData.nodes)
    .enter().append("g")
    .attr("class", "node")
    .call(d3.drag()  // Enable dragging behavior
      .on("start", dragStart)
      .on("drag", dragged)
      .on("end", dragEnd));

  node.append("circle")
    .attr("r", 20);

  node.append("text")
    .attr("dx", 0)
    .attr("dy", 5)
    .attr("text-anchor", "middle")
    .text(d => d.name);

  // Function that is called on every tick of the simulation
  function ticked() {
    // Update link positions
    link
      .attr("x1", d => d.source.x)
      .attr("y1", d => d.source.y)
      .attr("x2", d => d.target.x)
      .attr("y2", d => d.target.y);

    // Update node positions
    node
      .attr("transform", d => `translate(${d.x}, ${d.y})`);
  }

  // Dragging behavior
  function dragStart(event, d) {
    if (!event.active) simulation.alphaTarget(0.3).restart();  // Activate the simulation on drag
    d.fx = d.x;
    d.fy = d.y;
  }

  function dragged(event, d) {
    d.fx = event.x;
    d.fy = event.y;
  }

  function dragEnd(event, d) {
    if (!event.active) simulation.alphaTarget(0);  // Deactivate the simulation when dragging ends
    d.fx = null;
    d.fy = null;
  }

</script>